简析paxos协议

paxos协议原论文比较难以理解,但是paxos made simply这篇文章还是十分容易理解的(当然描述出来还是比较难的)。
paxos协议的主要目的是保证分布式系统状态的有序推进的共识算法,
分布式中的系统总是在每个阶段(epoch)提出一个值,并希望其他系统接受自己提出的值,
让自己来推进这个阶段(epoch)的状态。
在paxos中这个提出值被称为议题,议题由值组成,即{值}。
所以由上可知在一个paxos系统中,至少会有提出者(proposer)和接受者(acceptor)这两种角色。还有一个learning,它扮演记录员的角色。
无论什么情况下,只要proposer提出议题,我们希望总有议题被接受,所以paxos协议的第一个要求是:
P1. acceptor必须接收第一个它收到的proposal。(字面意思)
但是系统中的多个proposer的行为是不受控制的,同一阶段可能有多个proposer向不同的acceptor提出议题,
各个acceptor总是接受第一个发给自己的议题,但是这个被整个系统共识的唯一议题如何产生呢?或者说当一个议题被提出后,所有的其他的系统都能确定的得知这个议题被提出了。
一个简单的CAS问题,即 cmpxchg 议题未提出(old),{议题}(议题已提出(new)),被提出议题要像这样才行。
任意时刻可能会有多个acceptor接受一个议题,但是任意时刻有且仅有一个议题能被大多数acceptor接受。
所以使用共识算法的集群系统要求必须至少要有大于等于3台的奇数台系统。(奇数两个状态{被大多数接受,未被大多数接受},偶数三个给状态{被同样个数acceptor接受,被大多数接受,未被大多数接受})
cmpxchg 议题未提出(old),{编号,议题}(议题已提出(new)) 就变成了 cmpxchg 未被大多数接受(old),被大多数接受(议题已提出(new))
这里隐含了一个问题,如果 P1. acceptor必须接收第一个它收到的proposal。 ,那么达到半数+1的提出的议题如何让被接受其他议题的少数派接受自己。所以这里要求acceptor必须能接受多个收到的议题。
但是acceptor其实并不知道那个议题被提出了(只有proposer知道),如何避免提出议题后,后续的proposer覆盖这个已经提出的议题呢?
这里引出了poxos的第二个要求:
P2. 如果一个议案{v}被选择，那么所有被选择的议案包含的决议都是v。
如何达到这个要求呢?如果:
P2A. 如果一个议案{v}被选择，那么任何acceptor批准的议案包含的决议都是v。
如何达到这个要求呢?如果:
P2B. 如果一个议案{v}被选择，那么此后，任何proposer提出的议案包含的决议都是v。
也就是说,proposer需要得知这个被提出的议题,让后让自己将要提出的的议题变成被提出的议题,再提出。所以proposer的第一步需要先向多个acceptor获知它们接受的议题(这样才能提出提出的议题),
然后才能提出议题,显然paoxs协议需要分成两个阶段:阶段一,获知提出的议题\阶段二,提出议题(议题可能是自己选择的或者是已经提出的议题)。
想象一下,如何找到这个提出的议题?很简单,提出的议题是多数派接受的议题,那么proposer每次也向多数派获取这个议题,这个议题肯定是包含其中的。
但是,cceptor可能接受过其他的proposer的议题,但是议题没有提出。也就是说proposer获取的任意多数个acceptor接受的议题可能是不一样的。需要补充更多的条件来判断这个提出议题。
好了,如果我们给每个议题进行编号,议题变成了{编号,值}的形式,那么在任意多数派的集合中,这个提出的议题的编号是最大的, 那么proposer就能唯一的获取它。
所以所有的proposer在提出议题需要先获取一个编号,这个编号是全序的,因为proposer总是希望自己的议题被提出。编号总是一个比一个大。
P2C. 对于任意的v和n，如果议案{n, v}被提出，那么存在一个由acceptor的多数派组成的集合S，或者a) S中没有acceptor批准过编号小于n的议案，或者b) 在S的任何acceptor批准的所有议案（编号小于n）中，v是编号最大的议案的决议。
但是仔细想想,如果在所有acceptor没有接受议题的情况下,多个proposer同时去获取提出的议题,并且同时提出议题,那么先提的议题肯定会被后面的议题覆盖掉。可能被编号更小的覆盖,也可能被编号更大的覆盖。
首先如何解决被小于自己的议题覆盖呢?我们可以对p1进一步的约束来解决一个问题
P1A. acceptor可以批准一个编号为n的议案，当且仅当它没有回应过一个编号大于n的prepare请求。
P1A无法解决被更大编号覆盖的问题,那怎么办呢?
很简单,如果只让更大编号的议题才能被提出就可以解决了。
怎么才能做到更小编号的议题无法提出呢?毕竟提出虽然P1A只批准更大编号的议题,但是提出议题是看谁先被大多数接受。如果小编号的跑的更快,那么它的议题就能被提出。
解决这个问题的方法很简单,如果在获取提出议题的第一个阶段,proposer也对acceptor的可接受编号进行刷新。那要么拿到更大编号的proposer获取到提出的议题,
要么更小的编号的议题无法达到被大多数接受的地步。因为第一阶段就要刷新议题编号,所以需要第二阶段的acceptor可以接受相同的编号的议题,不同proposer不能获取出相同的编号。简单的做法就是 旧编号+n+系统编号。

所以paxos协议的全貌是:
P1. Acceptor必须批准它接收到的第一个决议。
P1A. acceptor可以批准一个编号为n的议案，当且仅当它没有回应过一个编号大于n的prepare请求。
P2. 如果一个议案{n, v}被选择，那么所有被选择的议案（编号更高）包含的决议都是v简析paxos协议

paxos协议原论文比较难以理解,但是paxos made simply这篇文章还是十分容易理解的(当然描述出来还是比较难的)。
paxos协议的主要目的是保证分布式系统状态的有序推进的共识算法,
分布式中的系统总是在每个阶段(epoch)提出一个值,并希望其他系统接受自己提出的值,
让自己来推进这个阶段(epoch)的状态。
在paxos中这个提出值被称为议题,议题由值组成,即{值}。
所以由上可知在一个paxos系统中,至少会有提出者(proposer)和接受者(acceptor)这两种角色。还有一个learning,它扮演记录员的角色。
无论什么情况下,只要proposer提出议题,我们希望总有议题被接受,所以paxos协议的第一个要求是:
P1. acceptor必须接收第一个它收到的proposal。(字面意思)
但是系统中的多个proposer的行为是不受控制的,同一阶段可能有多个proposer向不同的acceptor提出议题,
各个acceptor总是接受第一个发给自己的议题,但是这个被整个系统共识的唯一议题如何产生呢?或者说当一个议题被提出后,所有的其他的系统都能确定的得知这个议题被提出了。
一个简单的CAS问题,即 cmpxchg 议题未提出(old),{议题}(议题已提出(new)),被提出议题要像这样才行。
任意时刻可能会有多个acceptor接受一个议题,但是任意时刻有且仅有一个议题能被大多数acceptor接受。
所以使用共识算法的集群系统要求必须至少要有大于等于3台的奇数台系统。(奇数两个状态{被大多数接受,未被大多数接受},偶数三个给状态{被同样个数acceptor接受,被大多数接受,未被大多数接受})
cmpxchg 议题未提出(old),{编号,议题}(议题已提出(new)) 就变成了 cmpxchg 未被大多数接受(old),被大多数接受(议题已提出(new))
这里隐含了一个问题,如果 P1. acceptor必须接收第一个它收到的proposal。 ,那么达到半数+1的提出的议题如何让被接受其他议题的少数派接受自己。所以这里要求acceptor必须能接受多个收到的议题。
但是acceptor其实并不知道那个议题被提出了(只有proposer知道),如何避免提出议题后,后续的proposer覆盖这个已经提出的议题呢?
这里引出了poxos的第二个要求:
P2. 如果一个议案{v}被选择，那么所有被选择的议案包含的决议都是v。
如何达到这个要求呢?如果:
P2A. 如果一个议案{v}被选择，那么任何acceptor批准的议案包含的决议都是v。
如何达到这个要求呢?如果:
P2B. 如果一个议案{v}被选择，那么此后，任何proposer提出的议案包含的决议都是v。
也就是说,proposer需要得知这个被提出的议题,让后让自己将要提出的的议题变成被提出的议题,再提出。所以proposer的第一步需要先向多个acceptor获知它们接受的议题(这样才能提出提出的议题),
然后才能提出议题,显然paoxs协议需要分成两个阶段:阶段一,获知提出的议题\阶段二,提出议题(议题可能是自己选择的或者是已经提出的议题)。
想象一下,如何找到这个提出的议题?很简单,提出的议题是多数派接受的议题,那么proposer每次也向多数派获取这个议题,这个议题肯定是包含其中的。
但是,acceptor可能接受过其他的proposer的议题,但是议题没有提出。也就是说proposer获取的任意多数个acceptor接受的议题可能是不一样的。需要补充更多的条件来判断这个提出议题。
好了,如果我们给每个议题进行编号,议题变成了{编号,值}的形式,那么在任意多数派的集合中,这个提出的议题的编号是最大的, 那么proposer就能唯一的获取它。
所以所有的proposer在提出议题需要先获取一个编号,这个编号是全序的,因为proposer总是希望自己的议题被提出。编号总是一个比一个大。
P2C. 对于任意的v和n，如果议案{n, v}被提出，那么存在一个由acceptor的多数派组成的集合S，或者a) S中没有acceptor批准过编号小于n的议案，或者b) 在S的任何acceptor批准的所有议案（编号小于n）中，v是编号最大的议案的决议。
但是仔细想想,如果在所有acceptor没有接受议题的情况下,多个proposer同时去获取提出的议题,并且同时提出议题,那么先提的议题肯定会被后面的议题覆盖掉。可能被编号更小的覆盖,也可能被编号更大的覆盖。
首先如何解决被小于自己的议题覆盖呢?我们可以对p1进一步的约束来解决一个问题
P1A. acceptor可以批准一个编号为n的议案，当且仅当它没有回应过一个编号大于n的prepare请求。
P1A无法解决被更大编号覆盖的问题,那怎么办呢?
很简单,如果只让更大编号的议题才能被提出就可以解决了。
怎么才能做到更小编号的议题无法提出呢?毕竟提出虽然P1A只批准更大编号的议题,但是提出议题是看谁先被大多数接受。如果小编号的跑的更快,那么它的议题就能被提出。
解决这个问题的方法很简单,如果在获取提出议题的第一个阶段,proposer也对acceptor的可接受编号进行刷新。那要么拿到更大编号的proposer获取到提出的议题,
要么更小的编号的议题无法达到被大多数接受的地步。因为第一阶段就要刷新议题编号,所以需要第二阶段的acceptor可以接受相同的编号的议题,不同proposer不能获取出相同的编号。简单的做法就是 旧编号+n+系统编号。

所以paxos协议的全貌是:
P1. Acceptor必须批准它接收到的第一个决议。
P1A. acceptor可以批准一个编号为n的议案，当且仅当它没有回应过一个编号大于n的prepare请求。
P2. 如果一个议案{n, v}被选择，那么所有被选择的议案（编号更高）包含的决议都是v。
P2A. 如果一个议案{n, v}被选择，那么任何acceptor批准的议案（编号更高）包含的决议都是v。
P2B. 如果一个议案{n, v}被选择，那么此后，任何proposer提出的议案（编号更高）包含的决议都是v。
P2C. 对于任意的v和n，如果议案{n, v}被提出，那么存在一个由acceptor的多数派组成的集合S，或者a) S中没有acceptor批准过编号小于n的议案，或者b) 在S的任何acceptor批准的所有议案（编号小于n）中，v是编号最大的议案的决议。
并且分两个阶段
第一阶段:
a) Proposer选择一个议案编号n，向acceptor的多数派发送编号也为n的prepare请求。
b) Acceptor：如果接收到的prepare请求的编号n大于它已经回应的任何prepare请求，它就回应已经批准的编号最高的议案（如果有的话），并承诺不再回应任何编号小于n的议案；
第二阶段:
a) Proposer：如果收到了多数acceptor对prepare请求（编号为n）的回应，它就向这些acceptor发送议案{n, v}的accept请求，其中v是所有回应中编号最高的议案的决议，或者是proposer选择的值，如果回应说还没有议案。
b) Acceptor：如果收到了议案{n, v}的accept请求，它就批准该议案，除非它已经回应了一个编号大于n的议案。
Proposer可以提出多个议案，只要它遵循上面的算法。它可以在任何时刻放弃一个议案。（这不会破坏正确性，即使在议案被放弃后，议案的请求或者回应消息才到达目标）如果其它的proposer已经开始提出更高编号的议案，那么最好能放弃当前的议案。因此，如果acceptor忽略一个prepare或者accept请求（因为已经收到了更高编号的prepare请求），它应该告知proposer放弃议案。这是一个性能优化，而不影响正确性。
议题提出后learning对议题进行记录。
P2A. 如果一个议案{n, v}被选择，那么任何acceptor批准的议案（编号更高）包含的决议都是v。
P2B. 如果一个议案{n, v}被选择，那么此后，任何proposer提出的议案（编号更高）包含的决议都是v。
P2C. 对于任意的v和n，如果议案{n, v}被提出，那么存在一个由acceptor的多数派组成的集合S，或者a) S中没有acceptor批准过编号小于n的议案，或者b) 在S的任何acceptor批准的所有议案（编号小于n）中，v是编号最大的议案的决议。
并且分两个阶段
第一阶段:
a) Proposer选择一个议案编号n，向acceptor的多数派发送编号也为n的prepare请求。
b) Acceptor：如果接收到的prepare请求的编号n大于它已经回应的任何prepare请求，它就回应已经批准的编号最高的议案（如果有的话），并承诺不再回应任何编号小于n的议案；
第二阶段:
a) Proposer：如果收到了多数acceptor对prepare请求（编号为n）的回应，它就向这些acceptor发送议案{n, v}的accept请求，其中v是所有回应中编号最高的议案的决议，或者是proposer选择的值，如果回应说还没有议案。
b) Acceptor：如果收到了议案{n, v}的accept请求，它就批准该议案，除非它已经回应了一个编号大于n的议案。
Proposer可以提出多个议案，只要它遵循上面的算法。它可以在任何时刻放弃一个议案。（这不会破坏正确性，即使在议案被放弃后，议案的请求或者回应消息才到达目标）如果其它的proposer已经开始提出更高编号的议案，那么最好能放弃当前的议案。因此，如果acceptor忽略一个prepare或者accept请求（因为已经收到了更高编号的prepare请求），它应该告知proposer放弃议案。这是一个性能优化，而不影响正确性。
议题提出后learning对议题进行记录。